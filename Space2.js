// Generated by CoffeeScript 1.7.1
(function() {
  var HALF_PI, PI, Space2, TWO_PI, sameSign,
    __modulo = function(a, b) { return (a % b + +b) % b; };

  PI = Math.PI;

  TWO_PI = PI * 2;

  HALF_PI = PI * 0.5;

  sameSign = function(a, b) {
    return a * b >= 0;
  };

  Space2 = (function() {
    function Space2() {}


    /*
    Calculates the point on an ellipse at a specific angle.
    Only use this function when absolutely necessary. It is slow. For
    the purpose of drawing an ellipse, simply calculate the points on
    a circle and scale the x and y value. [Source and info] (http://mathforum.org/library/drmath/view/54922.html)
    
    @param angle in radians (<code>float</code>)
    @param width of the ellipse (<code>float</code>)
    @param height of the ellipse (<code>float</code>)
    @return position (<code>Vect2</code>)
     */

    Space2.ellipsePoint = function(angle, width, height) {
      var t, x, y;
      angle = __modulo(angle, TWO_PI);
      t = Math.atan(width) * Math.tan(angle) / height;
      if (angle > HALF_PI && angle < PI + HALF_PI) {
        t -= PI;
      }
      x = width * 0.5 * Math.cos(t);
      y = height * 0.5 * Math.sin(t);
      return new Vect2(x, y);
    };


    /*
    Calculates the distance from a point to a line.
    
    The distance is positive on the right side of the line (following point A to B),
    and negative on the other side.
    
    The distance is calculated as if the line is continues infinitely in both ends.
    
    @param point (<code>Vect2</code>)
    @param linePointA (<code>Vect2</code>)
    @param linePointB (<code>Vect2</code>)
    @return distance (<code>float</code>)
     */

    Space2.pointToLineDistance = function(point, linePointA, linePointB) {
      var a, b;
      a = ((linePointA.y - linePointB.y) * point.x) + ((linePointB.x - linePointA.x) * point.y) + ((linePointA.x * linePointB.y) - (linePointB.x * linePointA.y));
      b = ((linePointB.x - linePointA.x) * (linePointB.x - linePointA.x)) + ((linePointB.y - linePointA.y) * (linePointB.y - linePointA.y));
      return a / Math.sqrt(b);
    };


    /*
    Calculates whether a point is inside a polygon.
    
    Code is borrowed from this [Processing.org thread](http://processing.org/discourse/yabb_beta/YaBB.cgi?board=Programsaction=displaynum=1189178826).
    Thanks to [st33d](http://www.robotacid.com/) for the code.
    
    @param point containing the x,y coordinates to test (<code>Vect2</code>)
    @param vertices defining the polygon in the correct order (<code>Vect2[]</code>)
    @return true if the point is inside the polygon, otherwise false (<code>boolean</code>)
     */

    Space2.insidePolygon = function(_arg, vertices) {
      var c, i, id1, id2, j, p, pnum, poly, vertex, x, y, _i, _j, _len;
      x = _arg.x, y = _arg.y;
      poly = new Float32Array(vertices.length * 2);
      p = 0;
      for (_i = 0, _len = vertices.length; _i < _len; _i++) {
        vertex = vertices[_i];
        poly[p++] = vertex.x;
        poly[p++] = vertex.y;
      }
      pnum = vertices.length;
      c = 0;
      j = pnum - 1;
      for (i = _j = 0; 0 <= pnum ? _j < pnum : _j > pnum; i = 0 <= pnum ? ++_j : --_j) {
        id1 = i * 2;
        id2 = j * 2;
        if (((poly[id1 + 1] <= y && y < poly[id2 + 1]) || (poly[id2 + 1] <= y && y < poly[id1 + 1])) && x < (poly[id2] - poly[id1]) * (y - poly[id1 + 1]) / (poly[id2 + 1] - poly[id1 + 1]) + poly[id1]) {
          c = __modulo(c + 1, 2);
        }
        j = i;
      }
      return c === 1;
    };


    /*
    Calculates the intersection of two lines.
    
    The code comes from a post on Code & Form by Marius Watz, which led to a
    response with a more efficient algorithm taken from Graphics Gems. See
    the [original discussion](http://workshop.evolutionzone.com/2007/09/10/code-2d-line-intersection/).
    
    @param p1,p2,p3,p4 two pair of vectors each defining a line (```Vect2,Vect2,Vect2,Vect2```)
    @return null if there is no intersection, otherwise a vector containing the intersection coordinate (```Vect2```)
     */

    Space2.lineIntersection = function(_arg, _arg1, _arg2, _arg3) {
      var a1, a2, b1, b2, c1, c2, denom, intersection, num, offset, r1, r2, r3, r4, x1, x2, x3, x4, y1, y2, y3, y4;
      x1 = _arg.x, y1 = _arg.y;
      x2 = _arg1.x, y2 = _arg1.y;
      x3 = _arg2.x, y3 = _arg2.y;
      x4 = _arg3.x, y4 = _arg3.y;
      a1 = y2 - y1;
      b1 = x1 - x2;
      c1 = (x2 * y1) - (x1 * y2);
      r3 = (a1 * x3) + (b1 * y3) + c1;
      r4 = (a1 * x4) + (b1 * y4) + c1;
      if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {
        return null;
      }
      a2 = y4 - y3;
      b2 = x3 - x4;
      c2 = (x4 * y3) - (x3 * y4);
      r1 = (a2 * x1) + (b2 * y1) + c2;
      r2 = (a2 * x2) + (b2 * y2) + c2;
      if ((r1 !== 0) && (r2 !== 0) && sameSign(r1, r2)) {
        return null;
      }
      denom = (a1 * b2) - (a2 * b1);
      if (denom === 0) {
        return null;
      }
      offset = denom < 0 ? -denom / 2 : denom / 2;
      intersection = new Vect2();
      num = (b1 * c2) - (b2 * c1);
      intersection.x = num < 0 ? (num - offset) / denom : (num + offset) / denom;
      num = (a2 * c1) - (a1 * c2);
      intersection.y = num < 0 ? (num - offset) / denom : (num + offset) / denom;
      return intersection;
    };

    return Space2;

  })();

}).call(this);
